//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:/CODE/SysML2.NET/Resources/kebnf.g4 by ANTLR 4.13.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace SysML2.NET.CodeGenerator.Grammar {
using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.2")]
[System.CLSCompliant(false)]
public partial class kebnfParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, ASSIGN=8, ADD_ASSIGN=9, 
		BOOL_ASSIGN=10, PIPE=11, COLON=12, SEMICOLON=13, COMMA=14, LPAREN=15, 
		RPAREN=16, LBRACK=17, RBRACK=18, LBRACE=19, RBRACE=20, DOT=21, TILDE=22, 
		ID=23, INT=24, STRING=25, COMMENT=26, WS=27, CONTINUATION=28, NL=29;
	public const int
		RULE_specification = 0, RULE_rule_definition = 1, RULE_parameter_list = 2, 
		RULE_alternatives = 3, RULE_alternative = 4, RULE_element = 5, RULE_assignment = 6, 
		RULE_non_parsing_assignment = 7, RULE_non_parsing_empty = 8, RULE_cross_reference = 9, 
		RULE_group = 10, RULE_terminal = 11, RULE_non_terminal = 12, RULE_element_core = 13, 
		RULE_dotted_id = 14, RULE_suffix_op = 15, RULE_value_literal = 16;
	public static readonly string[] ruleNames = {
		"specification", "rule_definition", "parameter_list", "alternatives", 
		"alternative", "element", "assignment", "non_parsing_assignment", "non_parsing_empty", 
		"cross_reference", "group", "terminal", "non_terminal", "element_core", 
		"dotted_id", "suffix_op", "value_literal"
	};

	private static readonly string[] _LiteralNames = {
		null, "'*'", "'+'", "'?'", "'true'", "'false'", "'this'", "'[QualifiedName]'", 
		null, "'+='", "'?='", "'|'", "':'", "';'", "','", "'('", "')'", "'['", 
		"']'", "'{'", "'}'", "'.'", "'~'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, "ASSIGN", "ADD_ASSIGN", 
		"BOOL_ASSIGN", "PIPE", "COLON", "SEMICOLON", "COMMA", "LPAREN", "RPAREN", 
		"LBRACK", "RBRACK", "LBRACE", "RBRACE", "DOT", "TILDE", "ID", "INT", "STRING", 
		"COMMENT", "WS", "CONTINUATION", "NL"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "kebnf.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static kebnfParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public kebnfParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public kebnfParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class SpecificationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(kebnfParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] NL() { return GetTokens(kebnfParser.NL); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NL(int i) {
			return GetToken(kebnfParser.NL, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Rule_definitionContext[] rule_definition() {
			return GetRuleContexts<Rule_definitionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Rule_definitionContext rule_definition(int i) {
			return GetRuleContext<Rule_definitionContext>(i);
		}
		public SpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_specification; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterSpecification(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitSpecification(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSpecification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SpecificationContext specification() {
		SpecificationContext _localctx = new SpecificationContext(Context, State);
		EnterRule(_localctx, 0, RULE_specification);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 37;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==NL) {
				{
				{
				State = 34;
				Match(NL);
				}
				}
				State = 39;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 41;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 40;
				rule_definition();
				}
				}
				State = 43;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==ID );
			State = 45;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Rule_definitionContext : ParserRuleContext {
		public IToken name;
		public Parameter_listContext @params;
		public IToken target_ast;
		public AlternativesContext rule_body;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(kebnfParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] ID() { return GetTokens(kebnfParser.ID); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID(int i) {
			return GetToken(kebnfParser.ID, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlternativesContext alternatives() {
			return GetRuleContext<AlternativesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(kebnfParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(kebnfParser.SEMICOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] NL() { return GetTokens(kebnfParser.NL); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NL(int i) {
			return GetToken(kebnfParser.NL, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Parameter_listContext parameter_list() {
			return GetRuleContext<Parameter_listContext>(0);
		}
		public Rule_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rule_definition; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterRule_definition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitRule_definition(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRule_definition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Rule_definitionContext rule_definition() {
		Rule_definitionContext _localctx = new Rule_definitionContext(Context, State);
		EnterRule(_localctx, 2, RULE_rule_definition);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 47;
			_localctx.name = Match(ID);
			State = 49;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 48;
				_localctx.@params = parameter_list();
				}
			}

			State = 53;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLON) {
				{
				State = 51;
				Match(COLON);
				State = 52;
				_localctx.target_ast = Match(ID);
				}
			}

			State = 55;
			Match(ASSIGN);
			State = 56;
			_localctx.rule_body = alternatives();
			State = 58;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SEMICOLON) {
				{
				State = 57;
				Match(SEMICOLON);
				}
			}

			State = 61;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 60;
				Match(NL);
				}
				}
				State = 63;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==NL );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Parameter_listContext : ParserRuleContext {
		public IToken param_name;
		public IToken param_type;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(kebnfParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(kebnfParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(kebnfParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] ID() { return GetTokens(kebnfParser.ID); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID(int i) {
			return GetToken(kebnfParser.ID, i);
		}
		public Parameter_listContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter_list; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterParameter_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitParameter_list(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter_list(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Parameter_listContext parameter_list() {
		Parameter_listContext _localctx = new Parameter_listContext(Context, State);
		EnterRule(_localctx, 4, RULE_parameter_list);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 65;
			Match(LPAREN);
			State = 66;
			_localctx.param_name = Match(ID);
			State = 67;
			Match(COLON);
			State = 68;
			_localctx.param_type = Match(ID);
			State = 69;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlternativesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AlternativeContext[] alternative() {
			return GetRuleContexts<AlternativeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlternativeContext alternative(int i) {
			return GetRuleContext<AlternativeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] PIPE() { return GetTokens(kebnfParser.PIPE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PIPE(int i) {
			return GetToken(kebnfParser.PIPE, i);
		}
		public AlternativesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alternatives; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterAlternatives(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitAlternatives(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlternatives(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlternativesContext alternatives() {
		AlternativesContext _localctx = new AlternativesContext(Context, State);
		EnterRule(_localctx, 6, RULE_alternatives);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 71;
			alternative();
			State = 76;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==PIPE) {
				{
				{
				State = 72;
				Match(PIPE);
				State = 73;
				alternative();
				}
				}
				State = 78;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlternativeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ElementContext[] element() {
			return GetRuleContexts<ElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElementContext element(int i) {
			return GetRuleContext<ElementContext>(i);
		}
		public AlternativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alternative; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterAlternative(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitAlternative(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlternative(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlternativeContext alternative() {
		AlternativeContext _localctx = new AlternativeContext(Context, State);
		EnterRule(_localctx, 8, RULE_alternative);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 82;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 63602928L) != 0)) {
				{
				{
				State = 79;
				element();
				}
				}
				State = 84;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AssignmentContext assignment() {
			return GetRuleContext<AssignmentContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Non_parsing_assignmentContext non_parsing_assignment() {
			return GetRuleContext<Non_parsing_assignmentContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Non_parsing_emptyContext non_parsing_empty() {
			return GetRuleContext<Non_parsing_emptyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Cross_referenceContext cross_reference() {
			return GetRuleContext<Cross_referenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupContext group() {
			return GetRuleContext<GroupContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TerminalContext terminal() {
			return GetRuleContext<TerminalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Non_terminalContext non_terminal() {
			return GetRuleContext<Non_terminalContext>(0);
		}
		public ElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitElement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementContext element() {
		ElementContext _localctx = new ElementContext(Context, State);
		EnterRule(_localctx, 10, RULE_element);
		try {
			State = 92;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,8,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 85;
				assignment();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 86;
				non_parsing_assignment();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 87;
				non_parsing_empty();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 88;
				cross_reference();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 89;
				group();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 90;
				terminal();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 91;
				non_terminal();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentContext : ParserRuleContext {
		public Dotted_idContext property;
		public IToken op;
		public Element_coreContext content;
		public Suffix_opContext suffix;
		[System.Diagnostics.DebuggerNonUserCode] public Dotted_idContext dotted_id() {
			return GetRuleContext<Dotted_idContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Element_coreContext element_core() {
			return GetRuleContext<Element_coreContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(kebnfParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD_ASSIGN() { return GetToken(kebnfParser.ADD_ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOL_ASSIGN() { return GetToken(kebnfParser.BOOL_ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Suffix_opContext suffix_op() {
			return GetRuleContext<Suffix_opContext>(0);
		}
		public AssignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignment; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterAssignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitAssignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentContext assignment() {
		AssignmentContext _localctx = new AssignmentContext(Context, State);
		EnterRule(_localctx, 12, RULE_assignment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 94;
			_localctx.property = dotted_id();
			State = 95;
			_localctx.op = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 1792L) != 0)) ) {
				_localctx.op = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 96;
			_localctx.content = element_core();
			State = 98;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 14L) != 0)) {
				{
				State = 97;
				_localctx.suffix = suffix_op();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_parsing_assignmentContext : ParserRuleContext {
		public Dotted_idContext property;
		public IToken op;
		public Value_literalContext val;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACE() { return GetToken(kebnfParser.LBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACE() { return GetToken(kebnfParser.RBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Dotted_idContext dotted_id() {
			return GetRuleContext<Dotted_idContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Value_literalContext value_literal() {
			return GetRuleContext<Value_literalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(kebnfParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD_ASSIGN() { return GetToken(kebnfParser.ADD_ASSIGN, 0); }
		public Non_parsing_assignmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_parsing_assignment; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterNon_parsing_assignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitNon_parsing_assignment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_parsing_assignment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_parsing_assignmentContext non_parsing_assignment() {
		Non_parsing_assignmentContext _localctx = new Non_parsing_assignmentContext(Context, State);
		EnterRule(_localctx, 14, RULE_non_parsing_assignment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 100;
			Match(LBRACE);
			State = 101;
			_localctx.property = dotted_id();
			State = 102;
			_localctx.op = TokenStream.LT(1);
			_la = TokenStream.LA(1);
			if ( !(_la==ASSIGN || _la==ADD_ASSIGN) ) {
				_localctx.op = ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 103;
			_localctx.val = value_literal();
			State = 104;
			Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_parsing_emptyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACE() { return GetToken(kebnfParser.LBRACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACE() { return GetToken(kebnfParser.RBRACE, 0); }
		public Non_parsing_emptyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_parsing_empty; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterNon_parsing_empty(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitNon_parsing_empty(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_parsing_empty(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_parsing_emptyContext non_parsing_empty() {
		Non_parsing_emptyContext _localctx = new Non_parsing_emptyContext(Context, State);
		EnterRule(_localctx, 16, RULE_non_parsing_empty);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 106;
			Match(LBRACE);
			State = 107;
			Match(RBRACE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Cross_referenceContext : ParserRuleContext {
		public IToken @ref;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACK() { return GetToken(kebnfParser.LBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACK() { return GetToken(kebnfParser.RBRACK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(kebnfParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TILDE() { return GetToken(kebnfParser.TILDE, 0); }
		public Cross_referenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cross_reference; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterCross_reference(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitCross_reference(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCross_reference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Cross_referenceContext cross_reference() {
		Cross_referenceContext _localctx = new Cross_referenceContext(Context, State);
		EnterRule(_localctx, 18, RULE_cross_reference);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 110;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==TILDE) {
				{
				State = 109;
				Match(TILDE);
				}
			}

			State = 112;
			Match(LBRACK);
			State = 113;
			_localctx.@ref = Match(ID);
			State = 114;
			Match(RBRACK);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupContext : ParserRuleContext {
		public Suffix_opContext suffix;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(kebnfParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlternativesContext alternatives() {
			return GetRuleContext<AlternativesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(kebnfParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Suffix_opContext suffix_op() {
			return GetRuleContext<Suffix_opContext>(0);
		}
		public GroupContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_group; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterGroup(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitGroup(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroup(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupContext group() {
		GroupContext _localctx = new GroupContext(Context, State);
		EnterRule(_localctx, 20, RULE_group);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 116;
			Match(LPAREN);
			State = 117;
			alternatives();
			State = 118;
			Match(RPAREN);
			State = 120;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				{
				State = 119;
				_localctx.suffix = suffix_op();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TerminalContext : ParserRuleContext {
		public Value_literalContext val;
		public Suffix_opContext suffix;
		[System.Diagnostics.DebuggerNonUserCode] public Value_literalContext value_literal() {
			return GetRuleContext<Value_literalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Suffix_opContext suffix_op() {
			return GetRuleContext<Suffix_opContext>(0);
		}
		public TerminalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_terminal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterTerminal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitTerminal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTerminal(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TerminalContext terminal() {
		TerminalContext _localctx = new TerminalContext(Context, State);
		EnterRule(_localctx, 22, RULE_terminal);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 122;
			_localctx.val = value_literal();
			State = 124;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				{
				State = 123;
				_localctx.suffix = suffix_op();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Non_terminalContext : ParserRuleContext {
		public IToken name;
		public Suffix_opContext suffix;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(kebnfParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public Suffix_opContext suffix_op() {
			return GetRuleContext<Suffix_opContext>(0);
		}
		public Non_terminalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_non_terminal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterNon_terminal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitNon_terminal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNon_terminal(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Non_terminalContext non_terminal() {
		Non_terminalContext _localctx = new Non_terminalContext(Context, State);
		EnterRule(_localctx, 24, RULE_non_terminal);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 126;
			_localctx.name = Match(ID);
			State = 128;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,13,Context) ) {
			case 1:
				{
				State = 127;
				_localctx.suffix = suffix_op();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Element_coreContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Cross_referenceContext cross_reference() {
			return GetRuleContext<Cross_referenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GroupContext group() {
			return GetRuleContext<GroupContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TerminalContext terminal() {
			return GetRuleContext<TerminalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Non_terminalContext non_terminal() {
			return GetRuleContext<Non_terminalContext>(0);
		}
		public Element_coreContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_element_core; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterElement_core(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitElement_core(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElement_core(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Element_coreContext element_core() {
		Element_coreContext _localctx = new Element_coreContext(Context, State);
		EnterRule(_localctx, 26, RULE_element_core);
		try {
			State = 134;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,14,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 130;
				cross_reference();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 131;
				group();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 132;
				terminal();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 133;
				non_terminal();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Dotted_idContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] ID() { return GetTokens(kebnfParser.ID); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID(int i) {
			return GetToken(kebnfParser.ID, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] DOT() { return GetTokens(kebnfParser.DOT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT(int i) {
			return GetToken(kebnfParser.DOT, i);
		}
		public Dotted_idContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dotted_id; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterDotted_id(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitDotted_id(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDotted_id(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Dotted_idContext dotted_id() {
		Dotted_idContext _localctx = new Dotted_idContext(Context, State);
		EnterRule(_localctx, 28, RULE_dotted_id);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 136;
			Match(ID);
			State = 141;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DOT) {
				{
				{
				State = 137;
				Match(DOT);
				State = 138;
				Match(ID);
				}
				}
				State = 143;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Suffix_opContext : ParserRuleContext {
		public Suffix_opContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_suffix_op; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterSuffix_op(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitSuffix_op(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSuffix_op(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Suffix_opContext suffix_op() {
		Suffix_opContext _localctx = new Suffix_opContext(Context, State);
		EnterRule(_localctx, 30, RULE_suffix_op);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 144;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 14L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Value_literalContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(kebnfParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT() { return GetToken(kebnfParser.INT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING() { return GetToken(kebnfParser.STRING, 0); }
		public Value_literalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_value_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.EnterValue_literal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IkebnfListener typedListener = listener as IkebnfListener;
			if (typedListener != null) typedListener.ExitValue_literal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IkebnfVisitor<TResult> typedVisitor = visitor as IkebnfVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitValue_literal(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Value_literalContext value_literal() {
		Value_literalContext _localctx = new Value_literalContext(Context, State);
		EnterRule(_localctx, 32, RULE_value_literal);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 146;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 58720496L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,29,149,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,1,0,5,0,36,8,0,10,0,12,0,39,9,0,1,0,4,0,42,8,0,11,
		0,12,0,43,1,0,1,0,1,1,1,1,3,1,50,8,1,1,1,1,1,3,1,54,8,1,1,1,1,1,1,1,3,
		1,59,8,1,1,1,4,1,62,8,1,11,1,12,1,63,1,2,1,2,1,2,1,2,1,2,1,2,1,3,1,3,1,
		3,5,3,75,8,3,10,3,12,3,78,9,3,1,4,5,4,81,8,4,10,4,12,4,84,9,4,1,5,1,5,
		1,5,1,5,1,5,1,5,1,5,3,5,93,8,5,1,6,1,6,1,6,1,6,3,6,99,8,6,1,7,1,7,1,7,
		1,7,1,7,1,7,1,8,1,8,1,8,1,9,3,9,111,8,9,1,9,1,9,1,9,1,9,1,10,1,10,1,10,
		1,10,3,10,121,8,10,1,11,1,11,3,11,125,8,11,1,12,1,12,3,12,129,8,12,1,13,
		1,13,1,13,1,13,3,13,135,8,13,1,14,1,14,1,14,5,14,140,8,14,10,14,12,14,
		143,9,14,1,15,1,15,1,16,1,16,1,16,0,0,17,0,2,4,6,8,10,12,14,16,18,20,22,
		24,26,28,30,32,0,4,1,0,8,10,1,0,8,9,1,0,1,3,2,0,4,7,23,25,154,0,37,1,0,
		0,0,2,47,1,0,0,0,4,65,1,0,0,0,6,71,1,0,0,0,8,82,1,0,0,0,10,92,1,0,0,0,
		12,94,1,0,0,0,14,100,1,0,0,0,16,106,1,0,0,0,18,110,1,0,0,0,20,116,1,0,
		0,0,22,122,1,0,0,0,24,126,1,0,0,0,26,134,1,0,0,0,28,136,1,0,0,0,30,144,
		1,0,0,0,32,146,1,0,0,0,34,36,5,29,0,0,35,34,1,0,0,0,36,39,1,0,0,0,37,35,
		1,0,0,0,37,38,1,0,0,0,38,41,1,0,0,0,39,37,1,0,0,0,40,42,3,2,1,0,41,40,
		1,0,0,0,42,43,1,0,0,0,43,41,1,0,0,0,43,44,1,0,0,0,44,45,1,0,0,0,45,46,
		5,0,0,1,46,1,1,0,0,0,47,49,5,23,0,0,48,50,3,4,2,0,49,48,1,0,0,0,49,50,
		1,0,0,0,50,53,1,0,0,0,51,52,5,12,0,0,52,54,5,23,0,0,53,51,1,0,0,0,53,54,
		1,0,0,0,54,55,1,0,0,0,55,56,5,8,0,0,56,58,3,6,3,0,57,59,5,13,0,0,58,57,
		1,0,0,0,58,59,1,0,0,0,59,61,1,0,0,0,60,62,5,29,0,0,61,60,1,0,0,0,62,63,
		1,0,0,0,63,61,1,0,0,0,63,64,1,0,0,0,64,3,1,0,0,0,65,66,5,15,0,0,66,67,
		5,23,0,0,67,68,5,12,0,0,68,69,5,23,0,0,69,70,5,16,0,0,70,5,1,0,0,0,71,
		76,3,8,4,0,72,73,5,11,0,0,73,75,3,8,4,0,74,72,1,0,0,0,75,78,1,0,0,0,76,
		74,1,0,0,0,76,77,1,0,0,0,77,7,1,0,0,0,78,76,1,0,0,0,79,81,3,10,5,0,80,
		79,1,0,0,0,81,84,1,0,0,0,82,80,1,0,0,0,82,83,1,0,0,0,83,9,1,0,0,0,84,82,
		1,0,0,0,85,93,3,12,6,0,86,93,3,14,7,0,87,93,3,16,8,0,88,93,3,18,9,0,89,
		93,3,20,10,0,90,93,3,22,11,0,91,93,3,24,12,0,92,85,1,0,0,0,92,86,1,0,0,
		0,92,87,1,0,0,0,92,88,1,0,0,0,92,89,1,0,0,0,92,90,1,0,0,0,92,91,1,0,0,
		0,93,11,1,0,0,0,94,95,3,28,14,0,95,96,7,0,0,0,96,98,3,26,13,0,97,99,3,
		30,15,0,98,97,1,0,0,0,98,99,1,0,0,0,99,13,1,0,0,0,100,101,5,19,0,0,101,
		102,3,28,14,0,102,103,7,1,0,0,103,104,3,32,16,0,104,105,5,20,0,0,105,15,
		1,0,0,0,106,107,5,19,0,0,107,108,5,20,0,0,108,17,1,0,0,0,109,111,5,22,
		0,0,110,109,1,0,0,0,110,111,1,0,0,0,111,112,1,0,0,0,112,113,5,17,0,0,113,
		114,5,23,0,0,114,115,5,18,0,0,115,19,1,0,0,0,116,117,5,15,0,0,117,118,
		3,6,3,0,118,120,5,16,0,0,119,121,3,30,15,0,120,119,1,0,0,0,120,121,1,0,
		0,0,121,21,1,0,0,0,122,124,3,32,16,0,123,125,3,30,15,0,124,123,1,0,0,0,
		124,125,1,0,0,0,125,23,1,0,0,0,126,128,5,23,0,0,127,129,3,30,15,0,128,
		127,1,0,0,0,128,129,1,0,0,0,129,25,1,0,0,0,130,135,3,18,9,0,131,135,3,
		20,10,0,132,135,3,22,11,0,133,135,3,24,12,0,134,130,1,0,0,0,134,131,1,
		0,0,0,134,132,1,0,0,0,134,133,1,0,0,0,135,27,1,0,0,0,136,141,5,23,0,0,
		137,138,5,21,0,0,138,140,5,23,0,0,139,137,1,0,0,0,140,143,1,0,0,0,141,
		139,1,0,0,0,141,142,1,0,0,0,142,29,1,0,0,0,143,141,1,0,0,0,144,145,7,2,
		0,0,145,31,1,0,0,0,146,147,7,3,0,0,147,33,1,0,0,0,16,37,43,49,53,58,63,
		76,82,92,98,110,120,124,128,134,141
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
} // namespace SysML2.NET.CodeGenerator.Grammar
